An exact, copy-pasteable plan and commands to enforce the branching model you chose (`main`, `develop`, `feature/*`, `release/*`, `hotfix/*`) and set up GitHub **branch protection** rules so your team’s workflow is smooth and safe.

---

## 1) Branching model recap (short)

* `main` — **stable, production** branch. Only updated via tested, reviewed PRs (release merges or hotfix merges). Tagged releases live here.
* `develop` — **integration** branch for work in progress that will become the next release. (`feature/*` branches merge here).
* `feature/<short-name>` — developer branches for a single feature or task (branch off `develop`).
* `release/x.y` — short-lived branch for release preparation (from `develop` → testing → merge into `main`).
* `hotfix/<short-name>` — urgent fix branched off `main`, merged to `main` and `develop` after release.

---

## 2) Create the branches locally and push (exact commands)

Run these commands from your cloned repo root to create the canonical branches and push them to GitHub:

```bash
# make sure you are on latest main
git fetch origin

# create main branch locally (if not present) and push it
git checkout -b main
git push -u origin main

# create develop branch from main
git checkout -b develop
git push -u origin develop

# create a sample feature branch (example)
git checkout -b feature/ticket-model
git push -u origin feature/ticket-model

# create a sample release branch (example)
git checkout develop
git checkout -b release/0.1.0
git push -u origin release/0.1.0

# create a sample hotfix branch (example)
git checkout main
git checkout -b hotfix/fix-sla-bug
git push -u origin hotfix/fix-sla-bug
```

Keep branch names short and descriptive. Example naming conventions:

* `feature/<issue-number>-short-desc` → `feature/123-ticket-model`
* `hotfix/<issue-number>-short-desc` → `hotfix/456-fix-crash`

---

## 3) GitHub branch protection — recommended rules (UI steps)

Use the GitHub repository **Settings → Branches → Branch protection rules** and add rules for `main` and `develop`. Below are the recommended settings (copy each group into GitHub UI when creating a rule):

### A — Protect `main` (strict)

* Branch name pattern: `main`
* Require a pull request before merging: **checked**

  * Require approvals: **1 or 2** reviewers (choose `1` for small teams; `2` for higher safety).
* Require status checks to pass before merging: **checked**

  * Add required checks (from your CI) e.g.: `ci/lint`, `ci/test`, `ci/security_scan` — these names must match your GitHub Actions job names (see section 6).
* Require branches to be up to date before merging: **checked** (enables merge only when branch is rebased or up-to-date with target).
* Require review from Code Owners: **checked** (honors `.github/CODEOWNERS`)
* Dismiss stale pull request approvals when new commits are pushed: **checked**
* Require signed commits: optional but recommended — **checked** if your team will sign commits.
* Include administrators: **checked** (enforce for admins too) — recommended to prevent accidental direct pushes.

### B — Protect `develop` (less strict, but safe)

* Branch name pattern: `develop`
* Require a pull request before merging: **checked**

  * Require approvals: **1** reviewer
* Require status checks to pass before merging: **checked** (e.g., `ci/lint`, `ci/test`)
* Dismiss stale approvals: **checked**
* Require review from Code Owners: optional (you might keep this unchecked to allow more flexible merges into `develop`)
* Include administrators: optional (recommended to check)

### C — Pattern for `release/*` and `hotfix/*` (optional)

* Branch name pattern: `release/*` and `hotfix/*`
* Require PR for merges (merge to `main` or `develop` only after PR)
* Minimal reviewers: **1**
* Require status checks: **checked**

---

## 4) Why these settings?

* **Prevent direct pushes** to `main` ensures every change is reviewed and tested before production.
* **Status checks** enforce CI quality gates (linting + tests) automatically before merge.
* **CODEOWNERS** enforces domain experts review specific code areas.
* **Require up-to-date** avoids merging PRs that are stale & incompatible with the target branch — reduces integration bugs.

---

## 5) Enforcing branch protection via GitHub CLI / API

If you prefer automation, you can use the **GitHub CLI** (`gh`) or the GitHub REST API to create protection rules. Below is an example `gh api` `PATCH` you can run (replace `OWNER/REPO` and `GITHUB_TOKEN` is needed — `gh` uses your login token):

> **Warning:** run these commands from a safe terminal and ensure you have proper rights.

### Example using `gh api` (create `main` protection)

```bash
# set variables
OWNER="your-org-or-username"
REPO="helpdesk-app"

gh api -X PUT \
  -H "Accept: application/vnd.github+json" \
  /repos/$OWNER/$REPO/branches/main/protection \
  -f required_status_checks='{"strict":true,"contexts":["ci/lint","ci/test"]}' \
  -f enforce_admins=true \
  -f required_pull_request_reviews='{"required_approving_review_count":1,"dismiss_stale_reviews":true,"require_code_owner_reviews":true}' \
  -f restrictions='null'
```

### Example for `develop` protection

```bash
gh api -X PUT \
  -H "Accept: application/vnd.github+json" \
  /repos/$OWNER/$REPO/branches/develop/protection \
  -f required_status_checks='{"strict":true,"contexts":["ci/lint","ci/test"]}' \
  -f enforce_admins=false \
  -f required_pull_request_reviews='{"required_approving_review_count":1,"dismiss_stale_reviews":true,"require_code_owner_reviews":false}' \
  -f restrictions='null'
```

If you don’t use `gh`, you can call the GitHub REST API with `curl` and a `GITHUB_TOKEN`. See GitHub docs for branch protection API details.

---

## 6) CI job names — align with protection checks

Your GitHub Actions workflows should expose job names that match the contexts you put in protection rules. Example `ci.yml` jobs and job names:

```yaml
name: CI

on:
  pull_request:
  push:
    branches:
      - develop
      - main
      - 'feature/*'

jobs:
  lint:
    name: ci/lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install deps
        run: pip install -r requirements.txt
      - name: Run ruff
        run: ruff check .
      - name: Run black check
        run: black --check .

  test:
    name: ci/test
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_DB: helpdesk_db
          POSTGRES_USER: helpdesk
          POSTGRES_PASSWORD: helpdesk
        ports: ['5432:5432']
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7
        ports: ['6379:6379']
    steps:
      - uses: actions/checkout@v4
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.11
      - name: Install deps
        run: pip install -r requirements.txt
      - name: Run migrations
        run: python manage.py migrate --noinput
      - name: Run tests
        run: pytest -q
```

**Important:** the `name` field of the job (e.g., `ci/lint`, `ci/test`) is what shows up as the status check name in GitHub. Use these exact strings in branch protection required checks.

---

## 7) Pull request merging strategy & release process

### PR merge rules

* PRs should be **squash merged** into `develop` (or `main` for release merges) to keep history clean — enable "Allow squash merging" in repository settings.
* Require PRs to link an issue and include acceptance criteria.
* After a PR merge, the author should delete the branch (GitHub UI can do this automatically).

### Release flow

1. When `develop` has the features ready for a release, create a branch `release/x.y` from `develop`.
2. QA and staging testing happen from `release/x.y`. If fixes are needed, commit to `release/x.y`.
3. When stable, open PR `release/x.y → main`. Required checks & approvals run.
4. Merge PR into `main`. Tag the merge commit: `git tag -a v0.1.0 -m "Release v0.1.0"` and push the tag: `git push origin v0.1.0`.
5. Merge `main` back into `develop` (or create a PR `main → develop`) so bugfixes in release are present in develop.

### Hotfix flow

1. Branch `hotfix/<desc>` from `main`.
2. Fix, open PR `hotfix/* → main`. After merge, also merge `main → develop` to bring the fix to develop.

---

## 8) Protect tags / releases (optional but recommended)

You can restrict who can create releases/tags or require signed tags. Configure via repository settings → **Tags** or via CI. If you plan to publish Docker images from tags, gate publishing on `main` tag pushes only from GitHub Actions.

---

## 9) Checklist to finish Lesson 5 (do these now)

1. Create the branches locally and push (run commands from section 2).
2. Create branch protection rules for `main` and `develop` in GitHub UI (or run `gh api` commands in section 5).
3. Configure your GitHub Actions CI workflow with job `name` values that match the status checks you set in protection rules (see section 6).
4. Enable `Require review from Code Owners` and ensure `.github/CODEOWNERS` is present.
5. Enable "Require status checks to pass" and set the checks to the jobs from your CI.
6. Ensure "Require branches to be up to date before merging" is checked to reduce merge conflicts and keep PRs tested against the latest target branch.

---

## 10) Notes & best practices

* Set `required_approving_review_count` to 1 for faster cadence; increase to 2 for production-critical repos.
* Use protected branches to **prevent direct pushes** and accidental production changes.
* Keep `develop` slightly more permissive so fast iteration can continue; keep `main` conservative.
* Communicate to the team how to rebase or merge `develop` into feature branches and how to re-run CI.
* If using force pushes (not recommended), restrict them to specific team leads by enabling restrictions.

